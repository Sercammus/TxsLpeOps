{-
TorXakis - Model Based Testing
Copyright (c) 2015-2017 TNO and Radboud University
See LICENSE at root directory of this repository.
-}

TYPEDEF Sex ::= Male | Female ENDDEF

TYPEDEF Person ::=
    Person { sex :: Sex 
           ; firstName, lastName :: String
           ; dayOfBirth, monthOfBirth :: Int
           }
ENDDEF

FUNCDEF isValid_Person (p :: Person) :: Bool ::=
       strinre (firstName(p), REGEX ('[A-Z][a-z]*'))
    /\ strinre (lastName(p), REGEX ('[A-Z][a-z]*'))
    /\ (1 <= dayOfBirth(p)) /\ (dayOfBirth(p) <= 31)
    /\ (1 <= monthOfBirth(p)) /\ (monthOfBirth(p) <= 12)
ENDDEF

FUNCDEF isLuckyPerson (p :: Person; last :: Sex; n :: Int) :: Bool ::=
       isLuckyByGender(p, last, n)
    \/ isLuckyByName(p)
    \/ isLuckyByBirthday(p)
ENDDEF

FUNCDEF isLuckyByGender (p :: Person; last :: Sex; n :: Int) :: Bool ::=
    ( sex(p) <> last ) /\ ( n >= 5 )
ENDDEF

FUNCDEF isLuckyByName (p :: Person) :: Bool ::=
    at(firstName(p), 0 ) == at(lastName(p), 0 )
ENDDEF

FUNCDEF isLuckyByBirthday (p :: Person) :: Bool ::=
    dayOfBirth(p) == monthOfBirth(p)
ENDDEF

{-
 THE ORIGINAL:

PROCDEF luckyPeople [ In :: Person; Out :: Bool ] ( last :: Sex; n :: Int ) ::=
        In ? p [[ isValid_Person(p) ]] 
    >-> Out ! isLuckyPerson (p, last, n) 
    >->(
                ( [[ sex(p) == last ]] =>> luckyPeople[In,Out] ( sex(p), n+1 ) )
            ##
                ( [[ sex(p) <> last ]] =>> luckyPeople[In,Out] ( sex(p), 1 ) )
        )
ENDDEF
-}


{- result: leaving just one In -> Out -> ProcInst -}
{-
PROCDEF luckyPeople [ In :: Person; Out :: Bool ] ( last :: Sex; n :: Int ) ::=
        In ? p [[ isValid_Person(p) ]] 
    >-> Out ! isLuckyPerson (p, last, n) 
    >-> ( [[ sex(p) == last ]] =>> luckyPeople[In,Out] ( sex(p), n+1 ) )

ENDDEF
-}

{- this works -}
{- isValid_Person() becomes internally: -}
{- constraint = ValExpr {view = Vfunc (FuncId {name = "isValid_Person", unid = 1086, funcargs = [SortId {name = "Person", unid = 1047}], funcsort = SortId {name = "Bool", unid = 101}}) -}
{- LPE: 
            TXS >> lpe  luckyPeople[In, Out](Male,0)   
            TXS >>  LPE behaviour generated:
            TXS >>  LPE_luckyPeople [In,Out] ( 0, Male, 0, (ANY :: Sex), (ANY :: Int), (ANY :: Person) )
            TXS >> show procdef LPE_luckyPeople
            TXS >>  ( LPE_luckyPeople, PROCESS
            TXS >>  [ In Out ]
            TXS >>  [ pc$luckyPeople luckyPeople$In$Out$last luckyPeople$In$Out$n luckyPeople$gnf1$In$Out$last luckyPeople$gnf1$In$Out$n luckyPeople$gnf1$In$Out$p ]
            TXS >>  ::=
            TXS >>  ( { In ? In$1 :: Person}
            TXS >>  [[ ( IF ( 0 == pc$luckyPeople ) THEN isValid_Person( In$1 ) ELSE False FI ) ]]
            TXS >>  >-> ( LPE_luckyPeople [In,Out] ( 1, luckyPeople$In$Out$last, luckyPeople$In$Out$n, luckyPeople$In$Out$last, luckyPeople$In$Out$n, In$1 )
            TXS >>  ) )
            TXS >>  ##
            TXS >>  ( { Out ? Out$1 :: Bool}
            TXS >>  [[ ( IF ( 1 == pc$luckyPeople ) THEN ( Out$1 == isLuckyPerson( luckyPeople$gnf1$In$Out$p, luckyPeople$gnf1$In$Out$last, luckyPeople$gnf1$In$Out$n ) ) ELSE False FI ) ]]
            TXS >>  >-> ( LPE_luckyPeople [In,Out] ( 0, access Person 0 (luckyPeople$gnf1$In$Out$p), ( 1 + luckyPeople$gnf1$In$Out$n ), luckyPeople$gnf1$In$Out$last, luckyPeople$gnf1$In$Out$n, luckyPeople$gnf1$In$Out$p )
            TXS >>  ) )
            TXS >>  )
            TXS >>  
            TXS >> 
-}
{-
PROCDEF luckyPeople [ In :: Person; Out :: Bool ] ( last :: Sex; n :: Int ) ::=
        In ? p [[ isValid_Person(p) ]] 
    >-> Out ! isLuckyPerson (p, last, n) 
    >-> luckyPeople[In,Out] ( sex(p), n+1 ) 
ENDDEF
-}

{- works: take away the guard -}
{- 
PROCDEF luckyPeople [ In :: Person; Out :: Bool ] ( last :: Sex; n :: Int ) ::=
        In ? p 
    >-> luckyPeople[In,Out] ( sex(p), 1) 
ENDDEF
-}





{- ===== PROBLEM 1 ======== -}

PROCDEF luckyPeople [ In :: Person] ( last :: Sex) ::=
        In ? p 
    >-> [[ last == Male ]] =>> luckyPeople[In] ( sex(p)) 
ENDDEF 


{- works: remove sex(p) from the call -}
{-
PROCDEF luckyPeople [ In :: Person; Out :: Bool ] ( last :: Sex; n :: Int ) ::=
        In ? p 
    >-> [[ last == Male ]] =>> luckyPeople[In,Out] ( Male, 1) 
ENDDEF
-}

{- does NOT work -}
{- 
PROCDEF luckyPeople [ In :: Person; Out :: Bool ] ( last :: Sex; n :: Int ) ::=
        In ? p 
    >-> [[ last == Male ]] =>> luckyPeople[In,Out] ( sex(p), 1) 
ENDDEF
-}

{-
    lpe luckyPeople[In](Male) 
    show procdef LPE_luckyPeople
-}

CHANDEF Channels ::=  In   :: Person
                    ; Out  :: Bool
ENDDEF


MODELDEF Model ::=
    CHAN IN    In
    CHAN OUT   Out

    BEHAVIOUR  
        luckyPeople[In](Male)            -- first sex choice is arbitrary
ENDDEF



CONSTDEF separator :: String ::= "@" ENDDEF

CNECTDEF  Sut ::=
    CLIENTSOCK

    CHAN  OUT  In                   HOST "localhost"  PORT 7777
    ENCODE     In  ? p              ->  ! toString(sex(p))        ++ separator ++
                                          firstName(p)            ++ separator ++
                                          lastName(p)             ++ separator ++
                                          toString(dayOfBirth(p)) ++ separator ++
                                          toString(monthOfBirth(p))

    CHAN  IN   Out                  HOST "localhost"  PORT 7777
    DECODE     Out  ! fromString(s) <-  ? s
ENDDEF

CNECTDEF  Xut ::=
    CLIENTSOCK

    CHAN  OUT  In                   HOST "localhost"  PORT 7777
    ENCODE     In  ? p              ->  ! toXml(p)
    
    CHAN  IN   Out                  HOST "localhost"  PORT 7777
    DECODE     Out  ! fromXml(s)    <-  ? s
ENDDEF

CNECTDEF  Xim ::=
    SERVERSOCK

    CHAN IN   In                    HOST "localhost"  PORT 7777
    DECODE    In ! fromXml(s)       <-  ? s

    CHAN OUT  Out                   HOST "localhost"  PORT 7777
    ENCODE    Out ? b               ->  ! toXml(b)
ENDDEF
