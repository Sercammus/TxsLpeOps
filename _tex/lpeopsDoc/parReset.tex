\chapter{parReset}

\section{Introduction}

A linearized process may have parameters that are initialized, changed and used, and subsequently ignored until they are initialized again.
Parameters that often follow this pattern are \emph{control flow parameters}.

During the period in between the last change or use of a parameter and its subsequent initialization, a parameter could have different values.
These values contribute to the size of the state space of the process \emph{without} adding any new behavior!
It may therefore be advantageous to detect from which moment the value of a parameter is no longer used and set it to a default value instead.

\section{Algorithm}

The algorithm is a generalization of an existing algorithm \cite{van2009state}.
It consists of two phases, a preparation phase and an iteration phase.

\subsection{Preparation phase}

Consider all possible pairs of summands of the LPE (including symmetric pairs).
Of a given summand pair $(s, t)$, let $t$ be a \emph{successor} of $s$ if $s$ contains a recursive process instantiation and if the following equation is satisfiable:

\begin{align*}
c_s \land {c_t}[p \rightarrow v_s(p) \;|\; p \in P]
\end{align*}

where

\begin{itemize}
\item $c_s$ is the guard of summand $s$;
\item $c_t$ is the guard of summand $t$;
\item $P$ is the set of all process parameters;
\item $v_s$ is a function that yields the expression that summand $s$ assigns to a given process parameter in its recursive process instantiation.
\end{itemize}

During the preparation phase, we determine all successors of each summand of the LPE.
This gives an overapproximation of the control flow graph of the LPE.

\subsection{Iteration phase}

This phase follows these steps:

\begin{enumerate}

\item For each summand $s$, create a set $R_s$ that contains all process parameters.
This means that, initially, we assume that all process parameters are used by one or more of the successors of $s$.

\item For each summand $s$, set the value of $R_s$ to $\bigcup\limits_{t \in S_s}^{} r(t)$ where $S_s$ is the set of all successors of $s$ (as determined during the previous phase) and where $r$ is the function

\begin{align*}
r(t) = P \cap \left( \text{vars}(c_t) \cup \bigcup\limits_{x \in R_t}^{} v_t(x) \right)
\end{align*}

where

\begin{itemize}
\item $P$ is the set of all process parameters;
\item $\text{vars}(c_t)$ gives the free variables in $c_t$, the guard of summand $t$;
\item $v_t$ is a function that yields the expression that summand $t$ assigns to a given process parameter in its recursive process instantiation.
\end{itemize}

\item Repeat the previous step until the new value of $R_s$ is the same as before for all summands $s$.

\item For each summand $s$ and each process parameter $x \notin R_s$, change the recursive process instantiation of $s$ so that $x$ is assigned ${v_s}(x)[x \rightarrow x_0]$ for a choice of $x_0$ such that ${c_s}[x \rightarrow x_0]$ is satisfiable.
(This ensures that the set of summands that are successors of $s$ can only decrease.)

Note that it may be possible to merge summands in specific cases if the default value of $y$ is chosen cleverly and reused consistently.
To find the optimal solution, a combinatorial problem must be solved, which is not expected to have a proportional payoff.

\end{enumerate}

\clearpage
\section{Example}

Consider the following LPE:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0]] >-> example[A](1, i)
  + A ? i [[x==1 && i==y]] >-> example[A](2, y)
  + B [[x==2]] >-> example[A](3, y)
  + B [[x==3]] >-> example[A](0, y)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}

Finding the successors of each summand is easy: each summand has exactly one successor, namely the next one, except in case of the fourth summand, where the first summand is the successor.

It is also obvious that $x$ will always be in $R_s$ for each summand $s$, because each summand uses $x$ in its guard.

Process parameter $y$ will always be in $R_{s_1}$, where $s_1$ is the first summand, because $y$ is used in the guard of $s_1$'s successor (the second summand).
After a few iterations, however, $y$ is removed from $R_{s_2}$ to $R_{s_4}$.
This means that $y$ is assigned a default value in the corresponding summands.
Depending on the mood of the SMT solver, this could give

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0]] >-> example[A](1, i)
  + A ? i [[x==1 && i==y]] >-> example[A](2, 0)
  + B [[x==2]] >-> example[A](3, 0)
  + B [[x==3]] >-> example[A](0, 0)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}




